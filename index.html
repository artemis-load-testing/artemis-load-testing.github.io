<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.97.3"><meta name=viewport content="width=device-width,initial-scale=1"><title>Artemis</title><meta name=description content="Artemis is an open source, serverless framework for scalable load testing of your APIs."><link type=text/css rel=stylesheet href=https://artemis-load-testing.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://artemis-load-testing.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://artemis-load-testing.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://artemis-load-testing.github.io/css/hyde.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Baloo+Bhaijaan+2&family=Montserrat:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href=https://artemis-load-testing.github.io/index.xml rel=alternate type=application/rss+xml title=Artemis><div><a href=https://github.com/artemis-load-testing target=_blank><img class=github-icon src=/assets/github.svg></a></div></head><body class=theme-base-0g><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><img src=/apple-touch-icon-144-precomposed.png>
<a href=https://artemis-load-testing.github.io/><h1>Artemis</h1></a><p class=lead>Artemis is an open source, serverless framework for scalable load testing of your APIs.</p></div><nav><ul class=sidebar-nav><li><a href=/#introduction>Introduction</a></li><li><a href=/#overview_api_load_testing>APIs and Load Testing</a></li><li><a href=/#existing_solutions>Existing Solutions</a></li><li><a href=/#use_case>Use Case</a></li><li><a href=/#introducing_artemis>Introducing Artemis</a></li><li><a href=/#using_artemis>Using Artemis</a></li><li><a href=/#design_decisions>Design Decisions</a></li><li><a href=/#future_work>Conclusion & Future Work</a></li><li><a href=/#references>References</a></li><li><a href=/#presentation>Presentation</a></li><li><a href=/#our_team>Our Team</a></li></ul></nav></div></aside><main class="content container"><div class=posts><article class=post><div class=post><h1 id=artemis-case-study>Artemis Case Study</h1><h2 id=introduction>0. Introduction</h2><p>APIs are widely used and play an integral role in providing essential functionality to third-party applications. Given their vital nature, they should be tested continuously to ensure high availability. API load testing, or the process of simulating realistic traffic to an API to test its limits, can be performed using any number of available load testing tools in a local environment or in the cloud. Tests run locally often face a physical constraint, limiting the amount of load that can be generated. Alternatively, using a third-party cloud provider lacks flexibility in choosing test duration and volume on top of cost concerns.</p><p>Artemis is an open-source, serverless framework for scalable API load testing. It fills the gap by enabling the user to execute tests of varying volume and duration. The user can run tests that meet their needs, without the constraints of limited local resources or the limitations imposed by a paid cloud solution. Artemis is an easily deployable, cloud-based testing framework that provides near real-time results and robust data retention. Artemis utilizes an open-source load testing tool with a performant runtime (written in Go) that leverages a ubiquitous scripting language (JavaScript) and provides a clean, customizable dashboard to visualize test results in a meaningful way.</p><h3 id=01-artemis-quickstart-guide>0.1 Artemis Quickstart Guide</h3><p><strong>Artemis requires:</strong></p><ul><li>an<a href="https://portal.aws.amazon.com/gp/aws/developer/registration/index.html?nc2=h_ct&src=default"> AWS account</a></li><li>npm<a href=https://www.npmjs.com/get-npm> installed</a></li><li>AWS CLI<a href=https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html> installed</a> and configured</li><li><a href=https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html>AWS named profile</a></li><li>AWS CDK command-line tool<a href=https://docs.aws.amazon.com/cdk/latest/guide/cli.html> installed</a></li></ul><p><strong>Installation</strong></p><ul><li>run <code>npm install -g artemis-load-testing</code></li><li>run <code>artemis help</code> to see a list of available commands</li></ul><p><strong>Artemis Command List</strong></p><p>Usage: <code>artemis [options] [command]</code></p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>run-test</code></td><td>Run the test script concurrently the specified number of times.</td></tr><tr><td><code>grafana-start</code></td><td>Start the Artemis Grafana dashboard.</td></tr><tr><td><code>grafana-stop</code></td><td>Stop the Artemis Grafana dashboard.</td></tr><tr><td><code>deploy</code></td><td>Deploy Artemis infrastructure onto the user&rsquo;s AWS account.</td></tr><tr><td><code>sleep</code></td><td>Stop all supporting container tasks for minimal AWS usage charges.</td></tr><tr><td><code>teardown</code></td><td>Teardown Artemis infrastructure on user&rsquo;s AWS account, retain database.</td></tr><tr><td><code>destroy-db</code></td><td>Permanently delete the Artemis database.</td></tr><tr><td><code>admin-dashboard</code></td><td>Start admin dashboard GUI.</td></tr><tr><td><code>help</code></td><td>Display help for a specific command.</td></tr></tbody></table><p><strong>Login details for Artemis&rsquo; Grafana dashboard:</strong></p><table><thead><tr><th>username</th><th>password</th></tr></thead><tbody><tr><td><code>artemis</code></td><td><code>api_load_testing</code></td></tr></tbody></table><hr><h2 id=overview_api_load_testing>1. APIs and Load Testing</h2><h3 id=11-what-is-load-testing>1.1 What is load testing?</h3><figure><img src=../assets/6_what-is-load-testing.gif alt="Figure 1.1 What is load testing?"><figcaption><p>Figure 1.1 What is load testing?</p></figcaption></figure><p><strong>Load testing</strong> is the process of simulating the usage of an application, website, or collection of interconnected resources or services, to test their behavior under predefined conditions.</p><p>For example, a computer running a load test would simulate a number of users performing requests against a server under test. Results of this load test are then generated based on the responses received and specific metrics can be visualized based on those results.</p><h3 id=12-why-perform-a-load-test>1.2 Why perform a load test?</h3><figure><img src=../assets/7_why-load-test.gif alt="Figure 1.2 Why load test?"><figcaption><p>Figure 1.2 Why load test?</p></figcaption></figure><p>Load testing allows for errors, bugs, and bottlenecks to be identified and fixed before deployment into a production environment. Additionally, load testing can confirm assumptions made about the performance of a company’s existing infrastructure and its capacity.</p><h3 id=13-what-forms-of-load-testing-exist>1.3 What forms of load testing exist?</h3><p>There are two main branches of load testing: browser-based and protocol-based. <strong>Browser-based load testing</strong> is concerned with end-to-end testing of an application via its user interface (UI). User actions are the driving force and as such, tests are written from the perspective of a user interacting with the application through a browser.</p><p><strong>Protocol-based load testing</strong>, unlike browser-based testing, focuses on the performance of the underlying HTTP, or other network protocol, requests and doesn’t simulate the browser UI. For applications without a web UI, there is an argument for targeted, resource-efficient testing provided by protocol-based solutions.</p><p>API load testing follows a protocol-based load testing approach. Before delving further into API load testing, it’s important to establish a definition for API.</p><h3 id=14-what-is-api-load-testing>1.4 What is API load testing?</h3><figure><img src=../assets/8_what-is-api-load-testing.gif alt="Figure 1.3 What is API load testing?"><figcaption><p>Figure 1.3 What is API load testing?</p></figcaption></figure><p><strong>API</strong> stands for <strong>Application Programming Interface</strong>. APIs are vital tools for web applications since they allow the capabilities of one system to be used by another. If an application is treated as a black box, the API is like a set of rules that indicates how to interact with the application without having to know how the application works.</p><p><strong>API load testing</strong> is the process of simulating raw network requests, without regard to a graphical user interface, to measure the performance of a system. An effective API load test will generate the type of load a user would expect to see in production. This gives the user a realistic assessment of how their application architecture will behave and highlights any performance bottlenecks that need to be fixed before release. ​​</p><h3 id=15-why-would-apis-need-load-testing>1.5 Why would APIs need load testing?</h3><p>Calls to API endpoints make up an increasing amount of public and private network traffic. Networking giant Cloudflare has reported that more than 50% of the requests they process are API calls and that API call traffic is growing twice as fast as browser-based web traffic.¹</p><p>For some companies, APIs are the very focus of their business. Companies like this may expose several endpoints that perform tasks or retrieve data upon receiving requests. Since their APIs are their primary product, it is important to know at what point their performance would degrade, or at what point they would break altogether.</p><p>Global payment provider Stripe is an excellent example of this type of company.</p><figure><img src=../assets/12_stripe_api.png alt="Figure 1.4. What is Stripe?"><figcaption><p>Figure 1.4. What is Stripe?</p></figcaption></figure><p>Stripe provides an API that allows businesses to access its services without needing to know anything about how Stripe implements its core functionality of processing payments. Users just need to provide the relevant information to Stripe using the rules defined by Stripe’s API. It is up to Stripe to ensure that the user receives timely and meaningful responses to their requests.</p><p>High availability is essential for companies like Stripe and the customers that rely on them. They face severe consequences for any degradation of service when it comes to the performance of their APIs. As an example, a single minute of downtime on Black Friday could cost a business thousands, tens of thousands, or even hundreds of thousands of dollars. Conversely, a company that has done adequate load testing, and can perform as expected during peak traffic, puts itself in a position to maintain existing customers, attract new customers, and increase sales.</p><p>To get an understanding of what load testing entails, it is useful to start by looking at how a load test is written.</p><h3 id=16-what-does-a-load-test-typically-look-like>1.6 What does a load test typically look like?</h3><figure><img src=../assets/pokeapi.png alt="Figure 1.5 An example of an API load testing tool test script."><figcaption><p>Figure 1.5 An example of an API load testing tool test script.</p></figcaption></figure><p>Test scripts are executed with the help of a load testing tool. Load testing tools are used for load generation, simulating how real users would interact with an application, website, or other network resources that accept protocol-based requests. Figure 1.5 shows an example of a simple load test script. When a user writes a test script, the goal is to simulate a realistic number of users that will interact with the API and how they will interact with it. These simulated users are often referred to as virtual users.</p><p><strong>Virtual Users</strong> (<strong>VUs</strong>) mimic the behavior of a real user by performing separate, concurrent executions of a test script. For example, they can make HTTP requests against a webpage or API. A virtual user is not limited to making simple, single requests, but rather can execute an entire <em>scenario</em> of actions against a network resource.</p><p>A <strong>scenario</strong> describes a sequence of endpoints traversed by a virtual user. For example, for a standard e-commerce application, a scenario may involve making a call to a third-party API for checking out, which then makes subsequent calls to other endpoints for collecting payment details, verifying an account balance, and submitting a payment. Lines 12-17 in Figure 1.5 outline a scenario describing the endpoints that every virtual user will repeatedly execute for the duration of the test.</p><p>On line 6 in Figure 1.5, the target attribute with a value of 200 refers to the number of VUs to be simulated in the first two minutes of the test.</p><figure><img src=../assets/200_vus.png alt="Figure 1.6 A graph of virtual users simulated throughout a test."><figcaption><p>Figure 1.6 A graph of virtual users simulated throughout a test.</p></figcaption></figure><p>This particular test is designed to ramp from 0 to 200 virtual users (VUs) over the first two minutes, then gradually decrease the VU number to 100 over the next minute and a half, and finally, decrease the virtual user count to zero over the last 30 seconds of the load test. The desired change in VUs throughout the test is shown in Figure 1.6.</p><figure><img src=../assets/k6_output.png alt="Figure 1.7. An example of a load test output."><figcaption><p>Figure 1.7. An example of a load test output.</p></figcaption></figure><p>After the load test has completed execution, the user is presented with the results across a predefined collection of metrics. As shown in Figure 1.7, some of these key metrics include total HTTP requests made, average requests per second, request duration, and request failures.</p><figure><img src=../assets/fig1_8.png alt="Figure 1.8 Explanation of some key metrics from the test results output in Figure 1.7."><figcaption><p>Figure 1.8 Explanation of some key metrics from the test results output in Figure 1.7.</p></figcaption></figure><h2 id=existing_solutions>2. Existing Solutions</h2><p>Companies that need a flexible, performant load testing solution to ensure the high availability of their APIs generally pursue one of two avenues: implement an open-source tool in a local environment or pay for a cloud-based solution.</p><h3 id=21-local-open-source-load-testing-solutions>2.1 Local open-source load testing solutions</h3><p>JMeter, Gatling, and k6 are some of the more commonly used API load testing tools that are available and can be run locally.</p><p>Each of these tools provides the functionality to perform protocol-based load testing. These tools are written in a variety of different languages and vary in the way a user would create and run tests. JMeter has limited scripting capabilities; tests are composed primarily through a GUI whereas Gatling and k6 tests must be written as scripts in the prescribed language. For example, k6 tests are written entirely in JavaScript and Gatling tests are written in a domain-specific language (DSL).</p><figure><img src=../assets/fig2_1.png alt="Figure 2.1 Comparison chart of three prominent load testing tools: JMeter, Gatling, and k6 ²"><figcaption><p>Figure 2.1 Comparison chart of three prominent load testing tools: JMeter, Gatling, and k6 ²</p></figcaption></figure><p>A consideration when comparing local open-source solutions is memory requirements. In Figure 2.1, the max traffic generation capability results, measured in requests per second (RPS), are based on each tool running on the same hardware. Max traffic generation capability is closely tied to memory usage. A tool that is more resource-efficient will be able to perform a higher number of requests while using less memory. With such varying memory usage amounts, it is important to understand the capabilities of an individual machine before performing tests.</p><h3 id=22-limitations-of-using-open-source-solutions-locally>2.2 Limitations of using open-source solutions locally</h3><p>The following section discusses some limitations shared by API load testing tools, using k6 as an example.</p><h4 id=221-cpu-and-memory-restrictions>2.2.1 CPU and Memory restrictions</h4><p>The largest limitation when using an API load testing solution locally is that the amount of load generated is limited to a single machine’s memory and CPU. Even though k6 is typically considered a more performant load testing tool, CPU and memory limitations remain a concern.</p><p>Research was conducted to test the hardware limits of two standard computers that could be used in a development setting. Figure 2.2 summarizes the observations of this research. It shows the output for two tests of 600 and 1000 virtual users running the same two-minute test script on different machines. Computer 1 has 8GB RAM while computer 2 has 32 GB of RAM, both using an 8 core CPU.</p><figure><img src=../assets/fig2_2.png alt="Figure 2.2 A comparison of two computers with different compute resources simulating the same number of VUs but producing a different number of requests."><figcaption><p>Figure 2.2 A comparison of two computers with different compute resources simulating the same number of VUs but producing a different number of requests.</p></figcaption></figure><p>Due to lack of resources, computer 1 simulated the same number of requests for both 600 and 1000 virtual users. For this computer, the maximum number of VUs that can be simulated is 600. When this test was performed on computer 2, a machine with quadruple the memory, the total requests increased in proportion to the VUs simulated. In this case, the only way for computer 1 to simulate more VUs is to upgrade the machine’s memory.</p><p>The amount of CPU needed depends on the test script. The larger the test, the more CPU power is needed. If the chosen load testing tool uses too many CPU resources to generate load, there will not be enough resources left to adequately measure the responses received and result metrics will likely be reported incorrectly.</p><p>The amount of memory needed depends on the defined scenarios for a load test. The form in which result data is collected and output also impacts memory requirements. A simple k6 test will use around 1 to 5MB of memory per virtual user. This means for a simulation of 1000 virtual users, the memory consumed would range from 1 to 5GB. Local load testing tools, such as k6, can be used effectively for tests of a short to moderate duration and with a limited number of VUs. Anything beyond this limit requires additional non-trivial configuration and significantly increased CPU and memory.</p><h4 id=222-lack-of-access-to-results-as-test-is-running>2.2.2 Lack of access to results as test is running</h4><p>Another limitation in using local load testing tools is the lack of available results while the test is running. While this may not pose much of a problem in a short test of just a few minutes, when running longer tests there is little to no information about how the API is performing. Until the test completes and a summary view is output to the console, the developer can neither derive actionable insights nor cancel and restart a test based on real-time results.</p><figure><img src=../assets/k6_run.gif alt="Figure 2.3 Local k6 test running and completing from the CLI."><figcaption><p>Figure 2.3 Local k6 test running and completing from the CLI.</p></figcaption></figure><h4 id=223-no-graphical-representation-of-results-after-the-test-completes>2.2.3 No graphical representation of results after the test completes</h4><p>The open-source version of k6, like many other local load testing tools, provides no default graphical representation of test results. The user may specify an output file, in JSON or CSV format, to capture the more granular results of their tests as seen in Figure 2.4.</p><figure><img src=../assets/k6_csv_results.png alt="Figure 2.4 CSV k6 test result output, rows 12-48361 are hidden."><figcaption><p>Figure 2.4 CSV k6 test result output, rows 12-48361 are hidden.</p></figcaption></figure><p>However, the user will still need to come up with a way to process and parse that data and visualize it in a meaningful way.</p><h3 id=23-building-a-custom-solution-around-an-open-source-tool>2.3 Building a custom solution around an open-source tool</h3><p>Given the limitations described in the preceding sections, a company may consider building a custom solution around an open-source tool. As the application and testing framework grows, so should the load testing solution. Building a scalable load testing application is not an easy undertaking, however; along with committing resources for long-term maintenance, there are known risks with developing in-house tools that are not mission-critical.</p><figure><img src=../assets/22_inhouse-table.png alt="Figure 2.5 In-house solution features"><figcaption><p>Figure 2.5 In-house solution features</p></figcaption></figure><p>Additionally, technical debt and project delays can be expected due to the lack of domain expertise and effort spent on building a reliable tool. Assuming these challenges can be surmounted, the user is still at risk of reinventing the wheel unless a highly customized solution is a necessity. The biggest benefit of building a load testing solution from scratch is the flexibility of implementation, which the user pays for by managing several unknowns.</p><p>These challenges are usually enough to convince developer teams to search for pre-packaged solutions, which are available in the form of cloud-based tools.</p><h3 id=24-cloud-based-load-testing-solutions>2.4 Cloud-based load testing solutions</h3><p>Cloud-based SaaS load testing solutions are well-established and provide the sought-after traits of reliability and scalability. They abstract away much of the complexity required to automate tests, scale clusters, and produce visual results of the test data. Many open-source load testing solutions also offer enterprise-level software for performing large-scale tests from the cloud. BlazeMeter, Gatling Enterprise, and k6 Cloud are the cloud-based equivalents of JMeter, Gatling, and k6, respectively. These solutions address a number of the previously mentioned shortcomings of running tests locally. One such shortcoming is a lack of real-time results visualization. An example of how cloud-based solutions deal with this issue can be seen in Figure 2.6 which shows a k6 Cloud visualization dashboard.</p><figure><img src=../assets/k6_cloud.png alt="Figure 2.6 k6 Cloud test visualization"><figcaption><p>Figure 2.6 k6 Cloud test visualization</p></figcaption></figure><p>Cloud-based solutions provide real-time visualized results of the test. For some solutions, this is a built-in feature, whereas other solutions require setup to output results to a third-party tool. Real-time visualization of results indicates any performance concerns as they occur during the test. Imagine running a 6-hour test without any insight into the results, only to find out that there was an unexpectedly high failure rate within the first thirty minutes. Without near real-time result visualization, a user could be wasting potential development time waiting for the tests to complete.</p><p>A major benefit of using a cloud-based solution is the ability to simulate a much larger number of virtual users than could be achieved with a local load testing solution. The cloud provider is responsible for provisioning resources based on testing needs.</p><figure><img src=../assets/fig2_7.png alt="Figure 2.7 Comparison of highest tier cloud-based solutions as of April 2022"><figcaption><p>Figure 2.7 Comparison of highest tier cloud-based solutions as of April 2022</p></figcaption></figure><p>Figure 2.7 is an example of the highest tier monthly subscription offered by the aforementioned cloud providers. Many of these solutions also provide a separate breakdown for individual endpoints within a given scenario. Other features such as scheduling tests, generating reports, and providing performance insights are common amongst vendors in this space. Although the number of virtual users, test duration, and data storage differ between solutions, they share a common subscription model that locks users into the tier’s offerings.</p><h3 id=25-limitations-with-existing-cloud-solutions>2.5 Limitations with existing cloud solutions</h3><p>The following section discusses some limitations shared by cloud-based load testing tools, using k6 Cloud as an example.</p><h4 id=251-subscription-model-restrictions>2.5.1 Subscription model restrictions</h4><p>Cloud-based load testing tools typically require a subscription that imposes limitations as a function of that chosen tier.</p><figure><img src=../assets/21_k6cloud-tiers-table.png alt="Figure 2.8 k6 Cloud subscription tiers"><figcaption><p>Figure 2.8 k6 Cloud subscription tiers</p></figcaption></figure><p>As seen in Figure 2.8, if the user were subscribed to Tier 1 and wanted to run a continuous 30-minute test, they would need to upgrade to the next tier or settle for the 15 minute limit. If they wanted to simulate 2000 virtual users, Tier 3 would be the only option even if the test lasted 15-minutes or less. Although the user’s testing needs span multiple tiers, they would be forced to choose the least restrictive option and could be overpaying for functionality they do not need.</p><p>The subscription-based model these companies use locks users into only simulating a certain amount of virtual users, restricts them to tests of a certain length, and limits the number of total tests performed over a given period. Large companies do not have to choose; they can simply select the most expensive option as long as it gets the job done. Small and medium-sized companies do not have this luxury; they must choose between testing needs and budget.</p><figure><img src=../assets/23_saas-table.png alt="Figure 2.9 Software-as-a-service (SaaS) vendor features"><figcaption><p>Figure 2.9 Software-as-a-service (SaaS) vendor features</p></figcaption></figure><p>Cloud-based SaaS tools can be both costly and restrictive, providing unnecessary functionality of features while limiting testing usage.</p><h2 id=use_case>3. Use case</h2><p>Using a load testing tool locally is adequate for simulating a small amount of load, and when simple, summary reporting at the end of the test is sufficient. When larger-scale tests need to be performed and a more thorough result visualization is needed, cloud-based SaaS solutions can meet that need. These solutions also offer additional features but introduce testing limitations as well. If a user is only interested in overcoming the load and visualization limitations of a local tool and does not require additional features, then a cloud-based SaaS solution may not be the right fit.</p><p>Artemis allows users to overcome the load generation limitations of a single machine while providing access to near real-time results visualization. It does so while retaining the testing flexibility that a SaaS subscription tier may restrict.</p><h3 id=31-where-artemis-fits-in>3.1 Where Artemis fits in</h3><figure><img src=../assets/24_artemis-table.png alt="Figure 3.1. Artemis’ solution features"><figcaption><p>Figure 3.1. Artemis’ solution features</p></figcaption></figure><p>Artemis deploys the necessary infrastructure for performing API load tests to a user’s AWS account with a single CLI command. Users can run load tests without restrictions on the number of virtual users and the test duration. Aggregated test results can be visualized in near real-time with the provided dashboard, and test results are retained in long-term storage, allowing the user to further parse, transform or query the data as desired.</p><p>Artemis is not as feature-rich as some of the existing cloud solutions. It does not perform parallel tests or generate load across multiple regions. There is a limit of 20,000 virtual users that can be simulated. The results dashboard displays a limited set of metrics and scheduled tests are not a built-in feature.</p><p>However, Artemis is a flexible, scalable solution for users who are unable to build out a dedicated testing environment and for whom tiered cloud-based SaaS solutions are too restrictive or costly.</p><h2 id=introducing_artemis>4. Introducing Artemis</h2><h3 id=41-four-components>4.1 Four components</h3><p>Artemis’ architecture can be divided up into four different components as shown in Figure 4.1: load generation, aggregation, data storage, and result visualization.</p><figure><img src=../assets/50_this-is-artemis-full.gif alt="Figure 4.1. Artemis&amp;rsquo; Architecture"><figcaption><p>Figure 4.1. Artemis&rsquo; Architecture</p></figcaption></figure><ul><li>The first component is concerned with load generation. The load testing containers in this component simulate virtual users that perform requests against the API the user wishes to test.</li><li>The second component is concerned with the aggregation of the test results. A single container collects and processes all the test results generated by the load testing containers.</li><li>The third component is concerned with data storage. The aggregated test results are stored in a time-series database.</li><li>The fourth and final component is concerned with result visualization. The provided dashboard allows the user to visualize meaningful metrics generated by their load test.</li></ul><p>These components are discussed in greater depth in the upcoming <em>Design Decisions</em> section.</p><h3 id=42-deploying-artemis>4.2 Deploying Artemis</h3><p>Prior to load generation, the supporting infrastructure needs to be in place.</p><p>By using the command <code>artemis deploy</code>, the necessary components can be deployed to AWS. This command makes use of the AWS Cloud Development Kit (CDK), which is a framework for modeling cloud infrastructure, via code, that can then be synthesized and deployed to a user’s AWS environment. Artemis deploys serverless components, launched on-demand, meaning the user can run load tests without having to manage their own servers.</p><p>Deploying the infrastructure involves compiling the CDK code into a template which can then be used by the CloudFormation service to create the specified resources.</p><p>AWS CDK is not the only way to build out infrastructure on AWS. As mentioned previously, the CDK code must be translated into a CloudFormation template, which is a JSON or YAML file that indicates the resources the user wants to deploy and how they want them to be configured. The advantages of using the CDK for Artemis’ use case, instead of constructing a CloudFormation template directly, are many:</p><ul><li>It’s easier to get started with the CDK since it’s available in many commonly used programming languages.</li><li>The CDK documentation is easier to parse and the API reference is much more detailed compared to that of CloudFormation.</li><li>The CDK is an abstraction over CloudFormation, hence the code tends to be more concise. Artemis’ CDK code was 429 lines long, but the CloudFormation template spanned 1455 lines.</li></ul><h3 id=43-starting-a-test-with-artemis>4.3 Starting a test with Artemis</h3><p>Having deployed Artemis’ infrastructure, the user can utilize the Artemis CLI or built-in admin dashboard to initiate a load test. The user provides two inputs: the local file path to the test script and the number of load testing containers to spin up. The start command, <code>artemis run-test</code>, triggers an action causing the script to be uploaded to an S3 bucket and invokes a lambda function to spin up the total number of load testing containers specified by the user.</p><figure><img src=../assets/29_script-from-s3-bucket.png alt="Figure 4.2. Each task running the test gets a copy of the test script from S3"><figcaption><p>Figure 4.2. Each task running the test gets a copy of the test script from S3</p></figcaption></figure><p>S3 is AWS’ object storage service. Object storage provides a way to store unstructured data in a structurally flat data environment. There are no folders, directories, or complex hierarchies as in a file-based system. While cloud-based object storage is ideal for long-term data retention, here it was used as a means to an end; namely, as a simple way to copy a test script on a user’s machine to a resource that could be accessed by Artemis’ load testing containers.</p><p>Since local files can’t be read by a Lambda function, S3 serves as a stepping stone for getting the test script onto the AWS infrastructure. AWS Lambdas fall in the realm of Functions-as-a-Service. Functions-as-a-Service implementations make functions available on-demand to respond to events as they occur. The Functions-as-a-Service provider manages the underlying infrastructure and the user is charged by execution time. In Artemis’ case, the Start Test lambda pictured in Figure 4.2 spins up the specified number of containers. Each application in the container then creates a local copy of the test script and starts the test.</p><h2 id=using_artemis>5. Using Artemis</h2><p>Artemis’ infrastructure is accessible to the user through the built-in admin dashboard and CLI. This enables the user to run tests, visualize results, and manage, deploy, and teardown their load testing infrastructure in AWS.</p><h3 id=51-artemis-deploy>5.1 artemis deploy</h3><p>Deploying the infrastructure can be performed using <code>artemis deploy</code>. The user will receive confirmation in the terminal that the infrastructure was successfully deployed. A user would typically run this command once upon first using Artemis and before running any load tests.</p><figure><img src=../assets/deploy.gif alt="Figure 5.1 Demo of the artemis deploy command running in the CLI"><figcaption><p>Figure 5.1 Demo of the artemis deploy command running in the CLI</p></figcaption></figure><h3 id=52-artemis-teardown>5.2 artemis teardown</h3><p>When load testing has concluded, the infrastructure can be removed using <code>artemis teardown</code>. All components, except for the database, will be removed from the user’s AWS infrastructure. A separate command, <code>artemis destroy-db</code>, is available if a user wishes to delete the database storing Artemis’ results.</p><h3 id=heading></h3><figure><img src=../assets/artemis_teardown.gif alt="Figure 5.2 Demo of artemis teardown command running in the CLI"><figcaption><p>Figure 5.2 Demo of artemis teardown command running in the CLI</p></figcaption></figure><h3 id=53-artemis-run-test>5.3 artemis run-test</h3><p>To initiate a test through the Artemis CLI, the user executes <code>artemis run-test</code> and specifies the path to the test script and the number of containers to spin up to generate the desired load. The user is presented with a three minute spinner that represents Artemis’ timestamp coordination function. This function ensures that the user’s test, across all containers, starts at the same time. This functionality will be explained in greater depth in the next section.</p><p>After three-minutes have elapsed, the user is presented with confirmation that the test has started along with a unique ID assigned to the test. This ID will be present in every row of data in the database such that the data can be grouped by test when queried.</p><figure><img src=../assets/artemis_run_test.gif alt="Figure 5.3 Demo of the artemis run-test command running in the CLI"><figcaption><p>Figure 5.3 Demo of the artemis run-test command running in the CLI</p></figcaption></figure><p>Now that the test is running, the user can expect their test results to be stored in the database and may choose to launch a container running the Artemis Grafana dashboard.</p><h3 id=54-artemis-grafana-start>5.4 artemis grafana-start</h3><p>To use Artemis’ Grafana dashboard, the user runs <code>artemis grafana-start</code> from the CLI. Once the container is up and running, the user will receive an IP address that they can access to view the dashboard.</p><figure><img src=../assets/artemis_grafana_start.gif alt="Figure 5.4 Demo of the artemis grafana-start command running in the CLI"><figcaption><p>Figure 5.4 Demo of the artemis grafana-start command running in the CLI</p></figcaption></figure><p>Artemis’ default dashboard view displays the results of the most recent test, and the user can zoom into specific portions of the test by highlighting the areas of interest. A user is not confined to the provided dashboard and queries. They may add their own panels to the dashboard and define their own custom queries.</p><figure><img src=../assets/artemis_grafana2.gif alt="Figure 5.5 Demo of user interacting with the Artemis Grafana dashboard"><figcaption><p>Figure 5.5 Demo of user interacting with the Artemis Grafana dashboard</p></figcaption></figure><p>When a user no longer needs to use the dashboard, they can run <code>artemis grafana-stop</code> to terminate the container.</p><h3 id=55-artemis-sleep>5.5 artemis sleep</h3><p>Artemis also provides the command <code>artemis sleep</code> to stop both the Telegraf and Grafana containers. The user can think of this as ensuring their infrastructure is in a “low power mode”. This command is useful when a user doesn’t want to tear down their infrastructure but is finished testing for the moment and wants to make sure that no containers are running in the background to prevent incurring unnecessary AWS charges.</p><figure><img src=../assets/artemis_sleep.gif alt="Figure 5.6 Demo of the artemis sleep command running in the CLI"><figcaption><p>Figure 5.6 Demo of the artemis sleep command running in the CLI</p></figcaption></figure><h3 id=56-artemis-admin-dashboard>5.6 artemis admin-dashboard</h3><p>To launch the admin dashboard the user runs <code>artemis admin-dashboard</code>. This provides the Artemis user a visual interface to run all the previously mentioned CLI commands.</p><figure><img src=../assets/artemis_react_dash.png alt="Figure 5.7 Artemis admin dashboard"><figcaption><p>Figure 5.7 Artemis admin dashboard</p></figcaption></figure><p>This dashboard uses a React frontend to make API calls to endpoints defined in an Express.js backend to execute a CLI command on a button click.</p><h2 id=design_decisions>6. Design Decisions</h2><p>When building Artemis’ architecture, several options were considered to achieve the goal of a scalable and flexible solution. This section explores the design decisions and tradeoffs that were made while building Artemis.</p><h3 id=61-load-testing-tool>6.1 Load testing tool</h3><p>Artemis required the use of a load testing tool to create scenarios and generate the number of virtual users specified by those scenarios.</p><p>There were two characteristics of interest while evaluating different load testing tools for Artemis:</p><ul><li>User can write a test script in a ubiquitous language</li><li>Tool generates adequate load using minimal resources</li></ul><p>JMeter, Gatling, and k6 were the three options considered. All of these tools allow for API load testing, but differ when it comes to scripting vs non-scripting, the language used to write tests, and resources used to generate load.</p><p>While JMeter performs protocol-based load testing, test scripts are created in a GUI, making JMeter an unsuitable choice. Artemis needed a script-based tool to control functionality from the CLI. Additionally, the use case is aimed toward developers that would already be familiar with writing tests in code and using the CLI.</p><p>Gatling was closer to the required load testing tool as it is a script-based, non-GUI solution. However, to use Gatling, engineers would have to learn a domain-specific language (DSL). Engineers at a small or medium-sized company may not have the time to learn another language. It was preferred to use a widely used language, rather than a DSL, to fit the use case of being easy to deploy and use for web developers.</p><p>k6 aligned with this goal as test scripts are written in JavaScript. k6 itself is written in Go, which is built with performance in mind; its low memory footprint means k6 provides the capability of producing more load while using the same resources, compared to JMeter and Gatling. This made k6 a suitable choice to integrate into Artemis’ architecture.</p><h3 id=62-load-generation>6.2 Load generation</h3><p>Generating load at scale requires compute resources beyond what a local environment or single virtual machine can provide. Artemis’ solution coordinates the running of multiple containers within a Virtual Private Cloud. These containers are shown as tasks in Figure 6.1.</p><figure><img src=../assets/31_load-generation-architecture.png alt="Figure 6.1 Load generation component of Artemis’ architecture."><figcaption><p>Figure 6.1 Load generation component of Artemis’ architecture.</p></figcaption></figure><p>A <strong>Virtual Private Cloud</strong>, or <strong>VPC</strong>, is a secure, logically isolated portion of the AWS infrastructure where the user can deploy their own resources. These tasks generate virtual users that perform requests against the API the user wishes to test. In the next section, the elements that make up Artemis’ load testing containers will be examined.</p><h4 id=621-running-load-tests-in-the-cloud>6.2.1 Running load tests in the cloud</h4><p>Each of the load testing instances pulls a custom image from AWS’s public container repository, known as Elastic Container Registry or ECR. The custom image was configured and published to ECR. It includes k6 and the <code>artemis.js</code> Node application.</p><figure><img src=../assets/32_task-zoom-in.png alt="Figure 6.2 The internals of a single load testing container."><figcaption><p>Figure 6.2 The internals of a single load testing container.</p></figcaption></figure><p>The Node script, <code>artemis.js</code>, fetches the previously uploaded test script from the S3 bucket, waits for a prescribed period for test start coordination, then uses k6 to run the test based on the provided script. The test results are then sent to a separate container for aggregation.</p><p>During a regular load test, a user may be spinning up one or more of these containers. Where are these containers running and how is the scaling of these containers handled? The answer is AWS Fargate and AWS Elastic Container Service on a VPC.</p><p>AWS Fargate is a serverless compute engine for containers. Fargate’s serverless nature aligned with the goal of making Artemis serverless for its users. Artemis users can simply write load tests without the burden of determining the optimal compute power needed to run the tests.</p><p>Lambdas, and more generally Functions-as-a-Service, are also considered serverless. However, Lambda functions proved to be too restrictive since they can only be used for tasks that run for 15 minutes or less. This function timeout imposes a test duration limit on Artemis users, which was not acceptable for Artemis’ use case.</p><p>All of Artemis’ containerized applications run in Fargate instances. ECS allows Artemis to manage, deploy, and scale the containerized applications provisioned by Fargate. The number of instances specified by the user when running a test is used by ECS to determine the number of Fargate instances to spin up.</p><h4 id=622-challenge-determining-container-size-and-number-of-vus-per-container>6.2.2 Challenge: Determining container size and number of VUs per container</h4><p>One challenge when utilizing AWS Fargate instances is determining the best combination of CPU and memory for a specific use case. After testing various sizes of Fargate instances and analyzing Cloudwatch logs and graphical results for CPU and memory utilization, it was determined that the optimal number of Virtual Users per load testing container was 200. This gives the user flexibility in terms of overall total VUs and length of test duration. Artemis’ users write their test scripts for up to 200 VUs and then specify the number of tasks desired for a particular test run. With this information, Artemis can generate load across multiple containers to achieve a large total number of Virtual Users. For example, if a user wants to test for 5,000 VUs, they simply write their script based on 200 VUs and specify a task count of 25. Likewise, if a user wants to perform a load test that simulates 200 or fewer users, they can use the same test script and specify just one task.</p><figure><img src=../assets/33_fargate-tasks.png alt="Figure 6.3 Scaling of Fargate instances for an increasing number of virtual users."><figcaption><p>Figure 6.3 Scaling of Fargate instances for an increasing number of virtual users.</p></figcaption></figure><p>Although ECS and Fargate made it easy to spin up serverless instances, a way to coordinate the starting of load tests across these multiple instances remained a problem. Ideally, all virtual users should be executing requests at the same time to accurately simulate the desired load. Otherwise, test results would not accurately reflect the test input and therefore invalidate the test itself.</p><h4 id=623-challenge-starting-the-same-test-across-multiple-containers-at-the-same-time>6.2.3 Challenge: Starting the same test across multiple containers at the same time</h4><h4 id=heading-1></h4><figure><img src=../assets/34_async-test-start.gif alt="Figure 6.4 Tests start as soon as the container is spun up, leading to inaccurate results."><figcaption><p>Figure 6.4 Tests start as soon as the container is spun up, leading to inaccurate results.</p></figcaption></figure><p>The question to answer then became: How can the spinning up of instances be decoupled from the starting of a test?</p><p>AWS Step Functions was first considered to coordinate a series of lambdas for running tasks concurrently. AWS has a Distributed Load Testing Implementation Guide that makes use of Step Functions using worker tasks and a leader task. This required the leader task to communicate with each of the worker tasks using a Python script to create a socket on the workers to listen for a start message from the leader. This workflow went beyond what is described here to start multiple tests and would introduce unnecessary complexity to Artemis’ use case. Another option, and how the problem was ultimately addressed, was by introducing a delay to the running of the test script.</p><figure><img src=../assets/35_sync-test-start.gif alt="Figure 6.5 Test start at the same time, irrespective of when the container has spun up."><figcaption><p>Figure 6.5 Test start at the same time, irrespective of when the container has spun up.</p></figcaption></figure><p>This was achieved by generating a timestamp three minutes from when the Start Test Lambda is invoked. Each test container then calculates a specific wait time based on when it is created, using the initial timestamp as a reference. This wait time can be thought of as a container-specific timer, enabling test start synchronization.</p><h3 id=63-data-aggregation>6.3 Data aggregation</h3><p>A single container collects and processes all the test results generated by the load testing containers. To provide meaningful insights into the performance of the API, the metrics displayed to the user should reflect the load testing results across all containers.</p><figure><img src=../assets/38_architecture-aggregation-telegraf.png alt="Figure 6.6 A high level overview of Artemis’ data aggregation component."><figcaption><p>Figure 6.6 A high level overview of Artemis’ data aggregation component.</p></figcaption></figure><h4 id=631-why-aggregation-is-necessary>6.3.1 Why aggregation is necessary</h4><p>Generating load from multiple containers creates a problem in that the results generated by each container do not represent the load test as a whole. Instead, it represents the performance of the API from the viewpoint of a single container.</p><figure><img src=../assets/39_aggregating-funnel.png alt="Figure 6.7 A generic data aggregation workflow."><figcaption><p>Figure 6.7 A generic data aggregation workflow.</p></figcaption></figure><p>Aggregation of data was also necessary for providing meaningful results. Plotting too many data points would produce too much noise, inhibiting the user from understanding and interpreting the data correctly.</p><p>Data aggregation reduces the number of writes since the number of test results is reduced before they reach the database. Reads also go down, since Artemis’ Grafana dashboard does not need to query as many data points to display results.</p><p>A solution was needed that would allow Artemis to funnel test results from all containers into a central location, where the aggregation of said results could proceed. Two approaches were considered to solve this problem.</p><h4 id=632-challenge-aggregating-data-from-test-results>6.3.2 Challenge: Aggregating data from test results</h4><p>First, a polling-based approach was examined. In this approach, k6 would perform the load test from the test containers and the results would be written to a file in either JSON or CSV format. Artemis would then tail the results file, sending the gathered results to be aggregated.</p><figure><img src=../assets/40_polling-approach.gif alt="Figure 6.8 Polling test containers for results."><figcaption><p>Figure 6.8 Polling test containers for results.</p></figcaption></figure><p>An issue with this approach is that k6 consumes a large amount of memory when test results are written to a file. Every virtual user simulated by k6 stores a copy of its test result file in memory. This presented a problem because larger tests depleted the container memory prematurely and terminated the container. Even if k6 did not have this memory issue, the challenge of aggregation remained unsolved.</p><figure><img src=../assets/41_streaming-to-telegraf.gif alt="Figure 6.9 Streaming-based approach using Telegraf."><figcaption><p>Figure 6.9 Streaming-based approach using Telegraf.</p></figcaption></figure><p>A streaming-based approach was then considered. Instead of bi-directional communication, a streaming approach entails a one-way data flow in near real-time. Each load testing container sends data, as it is generated, to a single server. The server is configured to combine the results received at a regular time interval. After evaluating a number of data aggregation solutions, a tool called Telegraf was determined to be the right fit for Artemis.</p><figure><img src=../assets/42_what-is-telegraf.png alt="Figure 6.10 Example of Telegraf aggregating data points."><figcaption><p>Figure 6.10 Example of Telegraf aggregating data points.</p></figcaption></figure><p>Telegraf is an open-source data collection agent that is written in Go. It has no external dependencies and has minimal memory requirements. Telegraf includes dozens of built-in plugins that the user can activate as needed for their specific use case. These plugins provide a wide range of input, processing, aggregation, and output functionality.</p><p>Telegraf can receive data in <strong>line protocol</strong> <strong>format</strong> making it compatible with k6, which can output data in the same format through a built-in plugin. Telegraf’s BasicStats and Quantile plugins calculate the mean, min, max, count, and sum, as well as percentile values, of all the incoming data. These metrics are important for accurately representing the test results as a whole.</p><p>Telegraf was chosen since it permitted Artemis to stream the data from every single container running a k6 load test to a central location. The Telegraf container was configured to aggregate the incoming data every ten seconds, and then insert it into a database for long-term storage. A ten-second window was determined to substantially reduce the amount of raw data that needed to be stored while retaining meaningful insights into the test results.</p><h4 id=633-challenge-container-communication>6.3.3 Challenge: Container communication</h4><p>Having determined that Telegraf was Artemis’ best option for addressing the problem of data aggregation, the next problem to tackle was how to make the Telegraf container reachable by the numerous test containers executing <code>artemis.js</code> and running the user’s tests with k6.</p><p>While all of Artemis’ containers run on a single VPC, the serverless nature of the implementation means that container instances get spun up and torn down on demand, and the private and public IP addresses of the Telegraf container change whenever a new instance of Telegraf is created. A straightforward way for the current instance of the Telegraf container to be reachable by all of the test containers was needed.</p><figure><img src=../assets/44_route53.png alt="Figure 6.11 Setting and receiving an IP address from Route 53."><figcaption><p>Figure 6.11 Setting and receiving an IP address from Route 53.</p></figcaption></figure><p>This problem was solved by running the Telegraf container as a service within the ECS cluster and enabling <strong>service discovery</strong>. This allows for the ephemeral nature of the container to be maintained while providing a consistent service discovery endpoint for the test containers to connect to when sending results. If a user runs a test and a Telegraf instance is not running within the service, Artemis starts a new Telegraf container along with the test containers. Whenever a new Telegraf instance within that service is launched, ECS uses AWS CloudMap to update Route 53, which is AWS’ DNS service, with the IP address of the Telegraf container within the VPC. Route 53 then maps that address to the DNS of the service Artemis defined, so when the test containers send data to the endpoint <code>http://artemis-telegraf.artemis:8186</code>, it is correctly routed to the currently running instance of Telegraf.</p><h3 id=64-data-storage>6.4 Data storage</h3><p>The next problem to consider was how to best store data long-term for historical monitoring purposes while retaining the scalable and serverless quality of Artemis’ architecture.</p><figure><img src=../assets/43_architecture-timestream.png alt="Figure 6.12 High level overview highlighting the data storage component"><figcaption><p>Figure 6.12 High level overview highlighting the data storage component</p></figcaption></figure><h4 id=641-why-store-all-this-data>6.4.1 Why store all this data?</h4><p>Cloud-based SaaS load testing solutions typically offer one to six months of data retention. Early on, it was decided that Artemis would not impose any data retention restrictions to allow for better historical data analysis.</p><p>Storing data long-term allows the user to answer several important questions when an anomaly arises: Has this issue happened before? And if it has, when did it first start and why? Being able to search over months or years of historical data can be a huge advantage and may allow the user to more easily answer these questions. Additionally, the knowledge gained from historical data can provide the user with greater confidence in their system.</p><h4 id=642-time-series-databases>6.4.2 Time-series databases</h4><p>k6, the load testing tool at the center of Artemis, outputs test results as time-series data. <strong>Time-series data</strong> is a sequence of data points collected over time intervals, giving the user the ability to track changes over time. Time-series data can track changes over milliseconds, days, or even years. This type of data accumulates very quickly and normal databases are not designed to handle the large amounts of necessary writes.</p><p>k6 also recognizes how large amounts of data introduce an additional challenge: &ldquo;&mldr;a large load test will likely produce a massive amount of data points. On the storage side, the database will likely become another bottleneck…In this case, [a] team must choose a high-performing database, optimizing for this use case, and typically aggregating the data before storing it.&ldquo;³</p><p>The two main benefits that time-series databases provide over traditional databases are usability and scale. Usability refers to any features, like continuous queries, that enable the user to more easily perform data analysis. Time-series databases can offer greater scalability since they treat time as a first-class citizen. Treating time as a first-class citizen introduces efficiencies such as higher data ingest rates and faster queries at scale.</p><h4 id=643-prometheus-as-a-data-storage-solution>6.4.3 Prometheus as a data storage solution</h4><p>First, Prometheus was considered as a potential data storage solution. Prometheus is an open-source, metrics-based monitoring system and time-series database. The user can query data from Prometheus using its custom, independent query language, PromQL. PromQL has no overlap with other query languages used in time-series databases, hence the user would need to learn a new SQL-like syntax to utilize this solution.</p><p>k6 supports sending test result metrics to a Prometheus remote write endpoint through the use of an extension. To maintain Artemis’ serverless nature, the AWS Managed Prometheus service (AMP) would need to be used. AMP is a serverless solution where cost is based on the metrics ingested, stored, or queried. Otherwise, using Prometheus on AWS would require the user to manage an EC2 instance and thus not qualify as serverless.</p><p>The envisioned infrastructure would have a load testing container, running k6, streaming the test result data directly to the AMP remote write endpoint. Data aggregation was not considered at this point. This remote write endpoint would be provided by AMP immediately after creating a Prometheus instance. An issue with this approach is that AMP, as well as other AWS services, requires requests sent over HTTP to provide AWS authentication information through the SigV4, or Signature Version 4, signing process. Since k6 lacks the ability to do this, ways in which requests could be signed before they were sent to AMP were evaluated.</p><p>A potential solution involved running a sidecar container that would run AWS SigV4 Proxy. AWS SigV4 Proxy is an open-source project that looks for AWS SDK credentials in three different areas: environment variables, shared credentials file, or the IAM role for the ECS task role. Requests would be routed from k6 to the proxy, the proxy would sign these requests using the credentials found, and then the requests would be forwarded to AWS AMP. While this solution would allow AMP to accept the test results produced by k6, it would effectively double the number of containers deployed per test. Doubling the containers would duplicate the cost per test as well as introduce more points of failure.</p><h4 id=644-timestream>6.4.4 Timestream</h4><p>The next data storage solution that was examined was AWS Timestream. <strong>AWS Timestream</strong> is a scalable, serverless time-series database. Like AWS Managed Prometheus, Timestream&rsquo;s pricing is based on writes, queries, and storage. For Artemis’ use case, there were two qualities of Timestream that made it a better solution as the data storage component when compared to Prometheus: the query language used and the way data is stored.</p><p>Timestream uses SQL as its query language. Given the overall goal of making Artemis easy to use, enabling the user to query data in a widely used language like SQL was determined to be a better option than using a PromQL-based solution. Timestream stores data in both memory and magnetic stores. The in-memory store is used for recent data while the magnetic store is used for historical data. Timestream can automatically move data from the memory store to the magnetic store as it reaches a certain age. The magnetic store is a more cost-effective way of storing data; this is ideal for Artemis users since they might choose to retain their load test results over long periods.</p><p>This, combined with the fact that it integrates well with k6, Telegraf, and Artemis’ overall architecture implementation, made Timestream the right choice for Artemis’ data storage component.</p><figure><img src=../assets/44_telegraf_timestream.gif alt="Figure 6.13 Aggregated time-series data is inserted to Timestream database"><figcaption><p>Figure 6.13 Aggregated time-series data is inserted to Timestream database</p></figcaption></figure><h3 id=65-result-visualization>6.5 Result Visualization</h3><p>Artemis needed to provide the user with a means to make sense of the stored data in a way that was easy to understand. This leads to Artemis’ fourth and final component: result visualization.</p><figure><img src=../assets/45_architecture-grafana-dashboard.png alt="Figure 6.14 High level overview of the data visualization component"><figcaption><p>Figure 6.14 High level overview of the data visualization component</p></figcaption></figure><h4 id=651-grafana-dashboard>6.5.1 Grafana dashboard</h4><p><strong>Grafana</strong> provides an open-source solution for visualizing data over time via a customizable dashboard. It connects to several databases such as PostgreSQL, InfluxDB, MySQL, and AWS Timestream and allows the user to decide on what information to display by associating a data source and one or more database queries with a panel. A dashboard can be composed of several user-customized panels. At any point during the creation process, a dashboard’s configuration can be preserved as a JSON file and re-used as a template for other dashboards.</p><figure><img src=../assets/image30.png alt="Figure 6.15 A panel (top) and the associated data source and database query (bottom) that informs the graph displayed by the panel."><figcaption><p>Figure 6.15 A panel (top) and the associated data source and database query (bottom) that informs the graph displayed by the panel.</p></figcaption></figure><p>Grafana was chosen for its modular, easy-to-use dashboard that allows for data to be visualized in different ways. Grafana was connected to Amazon Timestream via a plugin available from Grafana Labs. Although Artemis provides a pre-configured dashboard view, the user has the flexibility to display additional metrics that they deem important.</p><p>As demonstrated in section 5.4, the Artemis CLI can be used to spin up a Grafana container that will automatically query the Timestream database. This will allow the user to visualize the results of their tests. Results are updated every ten seconds as the tests are running.</p><p>The Artemis Grafana dashboard includes custom database queries to display the following metrics in the dashboard: virtual users simulated, HTTP request duration, requests per second, and request errors. These metrics are often displayed in other load testing result visualizations and provide a baseline understanding of how the API is performing. For example, if the request rate (requests/second) does not correlate with the change in VUs, it could indicate a bottleneck.</p><p>The four summary panels shown at the top of the dashboard provide statistics to enable a user to see how their test is running at a glance.</p><p>Total requests per second show the number of requests made every second to all endpoints in the test script. On its own, this metric does not tell the user much about the performance of the API. But when request duration increases or errors start to appear, it lets the user know at what point their system starts to break.</p><figure><img src=../assets/grafana-top.png alt="Figure 6.16 Top half of the Grafana dashboard showing the four summary panels and total requests per second."><figcaption><p>Figure 6.16 Top half of the Grafana dashboard showing the four summary panels and total requests per second.</p></figcaption></figure><p>Figure 6.16 is the associated query that obtains the data from Timestream to illustrate the total requests/second. It locates the rows that have a value of <code>value_sum</code> within the measure_name column of the <code>http_reqs</code> table. A single <code>measure_value</code> within a <code>value_sum</code> row indicates the sum of HTTP requests made across all containers over the Telegraf aggregation period. On line 1, the sum of the number of HTTP requests is divided by the 10-second period to determine an approximate number of requests per second.</p><figure><img src=../assets/image18.png alt="Figure 6.17 Timestream query for total requests/second panel."><figcaption><p>Figure 6.17 Timestream query for total requests/second panel.</p></figcaption></figure><p>HTTP Request Duration displays how long it takes to perform the entire request-response cycle. This metric is represented in four different ways: <code>min</code>, <code>p90</code>, <code>p95</code>, and <code>max</code>. The percentile values allow the user to determine the request duration that most users are experiencing. If these percentiles are complemented with minimum and maximum measurements, then it is possible to have a much more complete view of the data and better understand how the system behaved.</p><figure><img src=../assets/red_dots.png alt="Figure 6.18 Bottom half of the Grafana dashboard showing three panels: HTTP Request Duration, HTTP Failures, and Virtual Users"><figcaption><p>Figure 6.18 Bottom half of the Grafana dashboard showing three panels: HTTP Request Duration, HTTP Failures, and Virtual Users</p></figcaption></figure><p>The HTTP Failures panel on the bottom left of Figure 6.18 displays dots that represent any response that returned with a status code in the 400 or 500 range. This allows the user to quickly determine how many errors occurred within a certain period.</p><p>The bottom right panel, Virtual Users, displays the total number of users simulated across all containers.</p><h2 id=future_work>7. Conclusion & Future Work</h2><p>In summary, Artemis addresses many of the inherent limitations of existing load testing solutions. Artemis deploys a flexible, scalable load testing infrastructure that enables users to visualize and store near-real-time results. This infrastructure is accessible by either Artemis’ CLI or graphical user interface.</p><p>Artemis is not feature-complete; some additional capabilities that could be incorporated in future versions:</p><ul><li>Artemis’ current infrastructure allows for testing up to 20,000 VUs. This limitation is a function of Artemis’ aggregation implementation. A way to scale this aggregation step to accommodate an even greater number of VUs should be explored.</li><li>The implementation of an automatically generated “executive summary” of the results of each test that could be easily shared across the user’s team or organization would be a valuable addition.</li><li>Currently, tests can be started on-demand only. Functionality that allows users to schedule tests should be incorporated.</li></ul><h2 id=references>8. References</h2><p><em>Citations</em></p><ul><li>¹<a href=https://blog.cloudflare.com/landscape-of-api-traffic/>Landscape of API Traffic - Cloudflare Blog</a></li><li>²<a href=https://k6.io/blog/comparing-best-open-source-load-testing-tools/>Open-source load testing tool review 2020</a></li><li>³<a href=https://k6.io/what-to-consider-when-building-or-buying-a-load-testing-solution/>What to Consider When Building or Buying a Load Testing Solution</a></li></ul><p><em>Books</em></p><ul><li><a href=https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/>Designing Data-Intensive Applications by Martin Kleppmann</a></li><li><a href=https://www.amazon.com/Hitchhiking-Guide-Testing-Projects-Step/dp/0988540207>The Hitchhiking Guide To Load Testing Projects: A Fun, Step-by-Step Walk-Through Guide by Leandro Melendez</a></li></ul><p><em>Articles</em></p><ul><li><a href=https://loadninja.com/articles/what-is-api-load-testing/>What is API Load Testing? - LoadNinja Blog</a></li><li><a href=https://k6.io/modern-load-testing-for-engineering-teams/>Modern Load Testing for Engineering Teams</a></li><li><a href=https://www.timescale.com/blog/what-the-heck-is-time-series-data-and-why-do-i-need-a-time-series-database-dcf3b1b18563/>What the heck is time-series data (and why do I need a time-series database)?</a></li><li><a href=https://www.graylog.org/post/the-importance-of-historical-log-data>The Importance of Historical Log Data</a></li><li><a href=https://www.flood.io/blog/browser-based-load-testing-in-2020>Browser-based load testing in 2020</a></li><li><a href=https://martinfowler.com/articles/practical-test-pyramid.html#RestApiEnd-to-endTest>The Practical Test Pyramid</a></li><li><a href=https://k6.io/pricing/>k6 Cloud Pricing</a></li><li><a href=https://grafana.com/grafana/dashboards/2587>k6 Load Testing Results in Grafana</a></li><li><a href=https://docs.aws.amazon.com/solutions/latest/distributed-load-testing-on-aws/test-workflow.html>Distributed Load Testing on AWS</a></li><li><a href=https://www.flood.io/blog/what-is-api-load-testing>What is API Load Testing? - Flood Blog</a></li></ul><p><em>Documentation</em></p><ul><li><a href=https://docs.influxdata.com/telegraf/v1.22/>Telegraf documentation</a></li><li><a href=https://grafana.com/docs/grafana/latest/>Grafana documentation</a></li><li><a href=https://k6.io/docs/>k6 documentation</a></li><li><a href=https://docs.aws.amazon.com/cdk/v2/guide/home.html>AWS CDK Developer Guide</a></li></ul><hr><h2 id=presentation>Presentation</h2><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/l-NEJnETKxs style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="Artemis Presentation"></iframe></div><hr><h2 id=our_team>Our Team</h2><div id=team><p>Our team of four software engineers collaborated remotely across four
different cities and three disparate timezones to build Artemis.
Please feel free to reach out to us if you have any questions about
Artemis or if you would like to discuss any of the topics mentioned in
our write up.</p><ul class=team-members><li class=individual><a href=https://hartman.dev target=_blank><img class=portrait src=../assets/charles.jpg alt="Charles Hartman"></a><h3>Charles<br>Hartman</h3><p>Portland, OR</p><div class=icon-bar><a href=https://www.linkedin.com/in/hartman-charles/ target=_blank><img class=icon src=../assets/linkedin.svg alt="LinkedIn icon"></a>
<a href=https://github.com/charleshartman target=_blank><img class=icon src=../assets/github.svg alt="Github icon"></a></div></li><li class=individual><a href=http://sophiemcgarity.tech/ target=_blank><img class=portrait src=../assets/sophie.jpg alt="Sophie McGarity"></a><h3>Sophie<br>McGarity</h3><p>Seattle, WA</p><div class=icon-bar><a href=https://www.linkedin.com/in/sophie-mcgarity-0866ba181/ target=_blank><img class=icon src=../assets/linkedin.svg alt="LinkedIn icon"></a>
<a href=https://github.com/sophiemcgarity target=_blank><img class=icon src=../assets/github.svg alt="Github icon"></a></div></li><li class=individual><a href=https://miajim.github.io target=_blank><img class=portrait src=../assets/mia.jpg alt="Mia Jimenez"></a><h3>Mia<br>Jimenez</h3><p>Fairfax, VA</p><div class=icon-bar><a href=https://www.linkedin.com/in/miajim target=_blank><img class=icon src=../assets/linkedin.svg alt="LinkedIn icon"></a>
<a href=https://github.com/miajim target=_blank><img class=icon src=../assets/github.svg alt="LinkedIn icon"></a></div></li><li class="individual raul"><a href=https://raulromerocano.dev target=_blank><img class=portrait src=../assets/raul.jpg alt="Raul Romero Cano"></a><h3>Raul<br>Romero Cano</h3><p>St. Johns, NL</p><div class=icon-bar><a href=https://www.linkedin.com/in/raul-r-05a433165/ target=_blank><img class=icon src=../assets/linkedin.svg alt="LinkedIn icon"></a>
<a href=https://github.com/romero-c-raul target=_blank><img class=icon src=../assets/github.svg alt="Github icon"></a></div></li></ul></div></div></article></div></main></body></html>